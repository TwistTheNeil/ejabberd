--- ejabberd-2.0.1.orig/doc/guide.tex
+++ ejabberd-2.0.1/doc/guide.tex
@@ -1710,12 +1710,15 @@
 \begin{description}
 \titem{ldap\_servers} \ind{options!ldap\_server}List of IP addresses or DNS names of your
 LDAP servers. This option is required.
+\titem{ldap\_encrypt} \ind{options!ldap\_encrypt}Type of connection encryption to the LDAP server.
+Allowed values are: \term{none}, \term{tls}.
+Note that STARTTLS is not supported.
+The default value is: \term{none}.
 \titem{ldap\_port} \ind{options!ldap\_port}Port to connect to your LDAP server.
-  The initial default value is~389, so it is used when nothing is set into the 
-configuration file. 
+The default port is~389 if encryption is disabled; and 636 if encryption is enabled.
 If you configure a value, it is stored in \ejabberd{}'s database. 
 Then, if you remove that value from the configuration file, 
-the value previously stored in the database will be used instead of the default 389.
+the value previously stored in the database will be used instead of the default port.
 \titem{ldap\_rootdn} \ind{options!ldap\_rootdn}Bind DN. The default value
   is~\term{""} which means `anonymous connection'.
 \titem{ldap\_password} \ind{options!ldap\_password}Bind password. The default
@@ -1777,14 +1780,18 @@
 Let's say \term{ldap.example.org} is the name of our LDAP server. We have
 users with their passwords in \term{"ou=Users,dc=example,dc=org"} directory.
 Also we have addressbook, which contains users emails and their additional
-infos in \term{"ou=AddressBook,dc=example,dc=org"} directory.  Corresponding
-authentication section should looks like this:
+infos in \term{"ou=AddressBook,dc=example,dc=org"} directory.
+The connection to the LDAP server is encrypted using TLS,
+and using the custom port 6336.
+Corresponding authentication section should looks like this:
 
 \begin{verbatim}
   %% authentication method
   {auth_method, ldap}.
   %% DNS name of our LDAP server
   {ldap_servers, ["ldap.example.org"]}.
+  {ldap_encrypt, tls}.
+  {ldap_port, 6336}.
   %% Bind to LDAP server as "cn=Manager,dc=example,dc=org" with password "secret"
   {ldap_rootdn, "cn=Manager,dc=example,dc=org"}.
   {ldap_password, "secret"}.
--- ejabberd-2.0.1.orig/src/ejabberd.cfg.example
+++ ejabberd-2.0.1/src/ejabberd.cfg.example
@@ -224,17 +224,26 @@
 %% List of LDAP servers:
 %%{ldap_servers, ["localhost"]}.    
 %%
-%% LDAP attribute that holds user ID:
-%%{ldap_uids, [{"mail", "%u@mail.example.org"}]}. 
+%% Encryption of connection to LDAP servers:
+%%{ldap_encrypt, tls}.
 %%
-%% Search base of LDAP directory:
-%%{ldap_base, "dc=example,dc=com"}. 
+%% Port connect to LDAP server:
+%%{ldap_port, 636}.
 %%
 %% LDAP manager:
-%%{ldap_rootdn, "dc=example,dc=com"}. 
+%%{ldap_rootdn, "dc=example,dc=com"}.
 %%
 %% Password to LDAP manager:
-%%{ldap_password, "******"}. 
+%%{ldap_password, "******"}.
+%%
+%% Search base of LDAP directory:
+%%{ldap_base, "dc=example,dc=com"}.
+%%
+%% LDAP attribute that holds user ID:
+%%{ldap_uids, [{"mail", "%u@mail.example.org"}]}.
+%%
+%% LDAP filter:
+%%{ldap_filter, "(objectClass=shadowAccount)"}.
 
 %%
 %% Anonymous login support:
--- ejabberd-2.0.1.orig/src/ejabberd_auth_ldap.erl
+++ ejabberd-2.0.1/src/ejabberd_auth_ldap.erl
@@ -24,6 +24,10 @@
 %%%
 %%%----------------------------------------------------------------------
 
+%%% Modified by Thomas Baden <roo@ham9.net> 2008 April 6th
+%%% Added {ldap_encrypt, none|tls|starttls} configuration option.
+%%% NOTICE: STARTTLS is not yet supported.
+
 -module(ejabberd_auth_ldap).
 -author('alexey@process-one.net').
 
@@ -359,9 +363,18 @@
 		   undefined -> [];
 		   Backups -> Backups
 		   end,
+    Encryption = ejabberd_config:get_local_option({ldap_encrypt, Host}),
     LDAPPort = case ejabberd_config:get_local_option({ldap_port, Host}) of
-		   undefined -> 389;
-		   P -> P
+		   undefined -> case Encryption of
+				    tls -> {Encryption, ?LDAPS_PORT};
+				    starttls -> {Encryption, ?LDAP_PORT};
+				    _ -> ?LDAP_PORT
+				end;
+		   P -> case Encryption of
+			    tls -> {Encryption, P};
+			    starttls -> {Encryption, P};
+			    _ -> P
+			end
 	       end,
     RootDN = case ejabberd_config:get_local_option({ldap_rootdn, Host}) of
 		 undefined -> "";
--- ejabberd-2.0.1.orig/src/eldap/eldap.erl
+++ ejabberd-2.0.1/src/eldap/eldap.erl
@@ -42,6 +42,12 @@
 %%% Modified by Mickael Remond <mremond@process-one.net>
 %%% Now use ejabberd log mechanism
 
+%%% Modified by Thomas Baden <roo@ham9.net> 2008 April 6th
+%%% Added LDAPS support, modeled off jungerl eldap.erl version.
+%%% NOTICE: STARTTLS is not yet supported.
+%%%
+%%% Modified by Andy Harb <Ahmad.N.Abou-Harb@jpl.nasa.gov> 2008 April 28th
+%%% Modified LDAPS support to work with ejabberd-2.0.0
 
 %%% --------------------------------------------------------------------
 -vc('$Id: eldap.erl 1237 2008-03-20 16:38:29Z mremond $ ').
@@ -87,18 +93,23 @@
 -define(CMD_TIMEOUT, 100000).
 -define(MAX_TRANSACTION_ID, 65535).
 -define(MIN_TRANSACTION_ID, 0).
+-define(SUPPORTEDEXTENSION, "1.3.6.1.4.1.1466.101.120.7").
+-define(SUPPORTEDEXTENSIONSYNTAX, "1.3.6.1.4.1.1466.115.121.1.38").
+-define(STARTTLS, "1.3.6.1.4.1.1466.20037").
 
 -record(eldap, {version = ?LDAP_VERSION,
 		hosts,         % Possible hosts running LDAP servers
 		host = null,   % Connected Host LDAP server
-		port = 389,    % The LDAP server port
+		port,          % The LDAP server port
 		fd = null,     % Socket filedescriptor.
 		rootdn = "",   % Name of the entry to bind as
 		passwd,        % Password for (above) entry
 		id = 0,        % LDAP Request ID 
 		bind_timer,    % Ref to bind timeout
 		dict,          % dict holding operation params and results
-		bind_q         % Queue for bind() requests
+		bind_q,        % Queue for bind() requests
+		use_tls = false,      % LDAP/LDAPS
+		use_starttls = false
 	}).
 
 %%%----------------------------------------------------------------------
@@ -375,6 +386,30 @@
 	{error, Reason} ->
 	    {stop, Reason}
     end;
+init({Hosts, Port, Rootdn, Passwd}) when is_tuple(Port) ->
+    %% The connection must be encrypted
+    %% Start the SSL server if it wasn't already started
+    catch ssl:start(),
+    case Port of
+	{tls, TLSPort} ->
+	    {ok, connecting, #eldap{hosts = Hosts,
+				    port = TLSPort,
+				    rootdn = Rootdn,
+				    passwd = Passwd,
+				    id = 0,
+				    dict = dict:new(),
+				    bind_q = queue:new(),
+				    use_tls = true}, 0};
+	{starttls, TCPPort} ->
+	    {ok, connecting, #eldap{hosts = Hosts,
+				    port = TCPPort,
+				    rootdn = Rootdn,
+				    passwd = Passwd,
+				    id = 0,
+				    dict = dict:new(),
+				    bind_q = queue:new(),
+				    use_starttls = true}, 0}
+    end;
 init({Hosts, Port, Rootdn, Passwd}) ->
     {ok, connecting, #eldap{hosts = Hosts,
 			    port = Port,
@@ -445,8 +480,12 @@
 %%          {next_state, NextStateName, NextStateData, Timeout} |
 %%          {stop, Reason, NewStateData}                         
 %%----------------------------------------------------------------------
+handle_event(close, _StateName, S) when S#eldap.use_tls == true ->
+    ssl:close(S#eldap.fd),
+    {stop, closed, S};
+
 handle_event(close, _StateName, S) ->
-    gen_tcp:close(S#eldap.fd),
+    do_close(S#eldap.fd, S),
     {stop, closed, S};
 
 handle_event(process_bind_q, active_bind, #eldap{bind_q=Q} = S) ->
@@ -488,11 +527,15 @@
 %%
 %% Packets arriving in various states
 %%
-handle_info({tcp, _Socket, Data}, connecting, S) ->
+handle_info({Tag, _Socket, Data}, connecting, S)
+  when Tag == tcp;
+       Tag == ssl ->
     ?DEBUG("eldap. tcp packet received when disconnected!~n~p", [Data]),
     {next_state, connecting, S};
 
-handle_info({tcp, _Socket, Data}, wait_bind_response, S) ->
+handle_info({Tag, _Socket, Data}, wait_bind_response, S)
+  when Tag == tcp;
+       Tag == ssl ->
     cancel_timer(S#eldap.bind_timer),
     case catch recvd_wait_bind_response(Data, S) of
 	bound                -> {next_state, active, S};
@@ -504,8 +547,11 @@
 				{next_state, connecting, S#eldap{fd = null}}
     end;
 
-handle_info({tcp, _Socket, Data}, StateName, S)
-  when StateName==active; StateName==active_bind ->
+handle_info({Tag, _Socket, Data}, StateName, S)
+  when StateName==active, Tag == tcp;
+       StateName==active, Tag == ssl;
+       StateName==active_bind, Tag == tcp;
+       StateName==active_bind, Tag == ssl ->
     case catch recvd_packet(Data, S) of
 	{reply, Reply, To, NewS} -> gen_fsm:reply(To, Reply),
 				    {next_state, StateName, NewS};
@@ -514,11 +560,13 @@
 	{error, _Reason}          -> {next_state, StateName, S}
     end;
 
-handle_info({tcp_closed, _Socket}, Fsm_state, S) ->
+handle_info({Tag, _Socket}, Fsm_state, S)
+  when Tag == tcp_closed;
+       Tag == ssl_closed ->
     ?WARNING_MSG("LDAP server closed the connection: ~s:~p~nIn State: ~p",
 	  [S#eldap.host, S#eldap.port ,Fsm_state]),
     F = fun(_Id, [{Timer, From, _Name}|_]) ->
-		gen_fsm:reply(From, {error, tcp_closed}),
+		gen_fsm:reply(From, {error, Tag}),
 		cancel_timer(Timer)
 	end,
     dict:map(F, S#eldap.dict),
@@ -527,10 +575,12 @@
 						 bind_q=queue:new()}),
     {next_state, NextState, NewS};
 
-handle_info({tcp_error, _Socket, Reason}, Fsm_state, S) ->
-    ?DEBUG("eldap received tcp_error: ~p~nIn State: ~p", [Reason, Fsm_state]),
+handle_info({Tag, _Socket, Reason}, Fsm_state, S)
+  when Tag == tcp_error;
+       Tag == ssl_error ->
+    ?DEBUG("eldap received ~p: ~p~nIn State: ~p", [Tag, Reason, Fsm_state]),
     %% XXX wouldn't it be safer to try reconnect ?
-    %% if we were waiting a result, we may mait forever
+    %% if we were waiting a result, we may wait forever
     %% cause request is probably lost....
     {next_state, Fsm_state, S};
 
@@ -586,7 +636,7 @@
 			     protocolOp = {Name, Request}},
     ?DEBUG("~p~n",[{Name, Request}]),
     {ok, Bytes} = asn1rt:encode('ELDAPv3', 'LDAPMessage', Message),
-    case gen_tcp:send(S#eldap.fd, Bytes) of
+    case do_send(S#eldap.fd, S, Bytes) of
     ok ->
 	Timer = erlang:start_timer(?CMD_TIMEOUT, self(), {cmd_timeout, Id}),
 	New_dict = dict:store(Id, [{Timer, From, Name}], S#eldap.dict),
@@ -784,7 +834,7 @@
     end.
 
 close_and_retry(S) ->
-    gen_tcp:close(S#eldap.fd),
+    do_close(S#eldap.fd, S),
     retry_connect().
 
 retry_connect() ->
@@ -841,9 +891,12 @@
 %%-----------------------------------------------------------------------
 connect_bind(S) ->
     Host = next_host(S#eldap.host, S#eldap.hosts),
-    TcpOpts = [{packet, asn1}, {active, true}, {keepalive, true}, binary],
+    TcpOpts = case S#eldap.use_tls of
+		  true -> [{packet, asn1}, {active, true}, binary];
+		  _ -> [{packet, asn1}, {active, true}, {keepalive, true}, binary]
+	      end,
     ?INFO_MSG("LDAP connection on ~s:~p", [Host, S#eldap.port]),
-    case gen_tcp:connect(Host, S#eldap.port, TcpOpts) of
+    case do_connect(Host, S, TcpOpts) of
 	{ok, Socket} ->
 	    case bind_request(Socket, S) of
 		{ok, NewS} ->
@@ -854,7 +907,7 @@
 							bind_timer = Timer}};
 		{error, Reason} ->
 		    ?ERROR_MSG("LDAP bind failed on ~s:~p~nReason: ~p", [Host, S#eldap.port, Reason]),
-		    gen_tcp:close(Socket),
+		    do_close(Socket, S),
 		    retry_connect(),
 		    {ok, connecting, S#eldap{host = Host}}
 	    end;
@@ -864,6 +917,23 @@
 	    {ok, connecting, S#eldap{host = Host}}
     end.
 
+do_connect(Host, State, Opts) when State#eldap.use_tls == false ->
+    gen_tcp:connect(Host, State#eldap.port, Opts);
+do_connect(Host, State, Opts) when State#eldap.use_tls == true ->
+    {_,_,X} = erlang:now(),
+    ssl:seed("bkrlnateqqo" ++ integer_to_list(X)),
+    ssl:connect(Host, State#eldap.port, [{verify,0}|Opts]).
+
+do_close(Socket, State) when State#eldap.use_tls == false ->
+    gen_tcp:close(Socket);
+do_close(Socket, State) when State#eldap.use_tls == true ->
+    ssl:close(Socket).
+
+do_send(Socket, State, Bytes) when State#eldap.use_tls == false ->
+    gen_tcp:send(Socket, Bytes);
+do_send(Socket, State, Bytes) when State#eldap.use_tls == true ->
+    ssl:send(Socket, Bytes).
+
 bind_request(Socket, S) ->
     Id = bump_id(S),
     Req = #'BindRequest'{version        = S#eldap.version,
@@ -873,7 +943,7 @@
 			     protocolOp = {bindRequest, Req}},
     ?DEBUG("Bind Request Message:~p~n",[Message]),
     {ok, Bytes} = asn1rt:encode('ELDAPv3', 'LDAPMessage', Message),
-    case gen_tcp:send(Socket, Bytes) of
+    case do_send(Socket, S, Bytes) of
 	ok -> {ok, S#eldap{id = Id}};
 	Error -> Error
     end.
--- ejabberd-2.0.1.orig/src/eldap/eldap.hrl
+++ ejabberd-2.0.1/src/eldap/eldap.hrl
@@ -19,6 +19,9 @@
 %%%
 %%%----------------------------------------------------------------------
 
+-define(LDAP_PORT, 389).
+-define(LDAPS_PORT, 636).
+
 -record(eldap_search, {scope = wholeSubtree,
 		       base = [],
 		       filter,
--- ejabberd-2.0.1.orig/src/mod_vcard_ldap.erl
+++ ejabberd-2.0.1/src/mod_vcard_ldap.erl
@@ -24,6 +24,10 @@
 %%%
 %%%----------------------------------------------------------------------
 
+%%% Modified by Thomas Baden <roo@ham9.net> 2008 April 6th
+%%% Added {ldap_encrypt, none|tls|starttls} configuration option.
+%%% NOTICE: STARTTLS is not yet supported.
+
 -module(mod_vcard_ldap).
 -author('alexey@process-one.net').
 
@@ -673,13 +677,26 @@
 			  ejabberd_config:get_local_option({ldap_servers, Host});
 		      Backups -> Backups
 		  end,
-    LDAPPort = case gen_mod:get_opt(ldap_port, Opts, undefined) of
-		   undefined ->
-		       case ejabberd_config:get_local_option({ldap_port, Host}) of
-			   undefined -> 389;
-			   P -> P
-		       end;
-		   P -> P
+    Encryption = case gen_mod:get_opt(ldap_encrypt, Opts, undefined) of
+		     undefined ->
+			 ejabberd_config:get_local_option({ldap_encrypt, Host});
+		     LDE -> LDE
+		 end,
+    LDAPPortOpt = case gen_mod:get_opt(ldap_port, Opts, undefined) of
+		      undefined -> ejabberd_config:get_local_option({ldap_port, Host});
+		      POpt -> POpt
+		  end,
+    LDAPPort = case LDAPPortOpt of
+		   undefined -> case Encryption of
+				    tls -> {Encryption, ?LDAPS_PORT};
+				    starttls -> {Encryption, ?LDAP_PORT};
+				    _ -> ?LDAP_PORT
+				end;
+		   P -> case Encryption of
+			    tls -> {Encryption, P};
+			    starttls -> {Encryption, P};
+			    _ -> P
+			end
 	       end,
     LDAPBase = case gen_mod:get_opt(ldap_base, Opts, undefined) of
 		   undefined ->
